# Лабораторная №3 по теме "Фильтруемый список в React"
### Продолжаем разработку в духе TDD: вначале пишем тесты, потом пишем компонент, который проходит тесты.

## Задание 1
Каждый элемент списка должен обладать [контролируемым](https://reactjs.org/docs/forms.html#controlled-components)
чекбоксом. При изменении состояния чекбокса нужно сохранять актуальное значение в том же стейте, где лежит список
дел.

## Задание 2
Осуществить фильтрацию списка в соответствии со значением чекбокса "Только выполненные".

## Задание 3 _[опционально]_
Выделить стор в отдельный файл. В нём сделать функцию reducer, принимающую на вход действие (action) и предыдущее
состояние стора, и выдающую новое состояние стора.

Традиционный формат объекта action: поле type характеризует, что надо делать; поле payload содержит полезную нагрузку.

Для стора надо написать вначале тесты, потом реализовывать сам стор.

Фильтрующая функция тоже должна жить в сторе. Такие функции традиционно называются селекторы.


## Разработка через TDD
Требования к компонентам:

### ListItem
* Должен отображает на экране то, что передали в пропсе title.
* Должен показывать на экране кнопку.
  * При нажатии на кнопку должен вызываться переданный в пропсах коллбэк handleDelete.
  * Коллбэк должен вызываться с параметром id, который мы передаём в компонент.
* Должен показывать на экране чекбокс.
  * Состояние чекбокса зависит от переданного пропса checked.
  * При клике на чекбокс должен вызываться переданный в пропсах коллбэк handleChecked.
  * Коллбэк должен вызываться с параметром id, который мы передаём в компонент.

### List
* Позитивный кейс: отображение непустого списка:
  * Компонент выводит каждый элемент списка.
  * Кнопка в каждом элементе нажимается, при этом вызывается handleDelete с параметром id.
  * Чекбокс в каждом элементе прокликивается, при этом вызывается handleChecked с параметром id.
* Негативный кейс: отображение пустого списка:
  * Выводится надпись "В списке нет элементов".

### Form
* Отображается поле для ввода и кнопка "Добавить".
* Можно ввести что-то в поле для ввода.
* При нажатии на кнопку вызывается handleSubmit с параметром,
  равным тому, что ввели в поле для ввода.

### Store _[опционально]_
* При вызове редьюсера с экшеном add возвращается состояние стора, в котором добавлен новый элемент.
* При вызове редьюсера с экшеном delete возвращается состояние стора, в котором удалён указанный элемент.
* При вызове редьюсера с экшеном check возвращается состояние стора, в котором состояние указанного элемента изменено.
```jsx
export const ACTION_TYPES = {
    ADD: 'add',
    /* тут ещё варианты */
};

export const initialState = [];

export function reducer(action, prevState = initialState) {
    switch (action.type) {
        case ACTION_TYPES.DELETE: {
            return [...prevState.filter(item => item.id !== action.payload)];
        }
        /* тут ещё варианты */
        default: return [...prevState];
    }
}

export function selectFilteredList({list, isDone}) {
    if (!isDone) return list;

    return list.filter(element => element.isChecked);
}

// в App.jsx:
  function dispatch(action) {
    setList(reducer(action, list));
  }
// ...
      <List
        list={selectFilteredList({list, isDone})}
        dispatch={dispatch}/>

// в Item.jsx:
        <button onClick={() => dispatch({type: ACTION_TYPES.DELETE, payload: id})}>
            [x]
        </button>
```

## Способ выполнения
* Сделать форк этого репозитория. 
* Разработку вести через TDD: вначале тесты, потом компонент.
* Решение без тестов приниматься не будет.
* Результат оформить в виде pull request.

## Запуск
```
npm i
```

```
npm start
```

## Запуск тестов
```npm run test```
